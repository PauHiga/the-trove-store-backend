# 01 - Create basic MEN

M.E.N. stands for Mongo Express Node.

This part covers:
- Create a new Node project
- Set up a simple Express app with routes to make HTTP GET requests
- Create an account in MongoDB Atlas
- Use Mongoose from a .js file to create a collection, add items to the collection and fetch items from the collection.
- Combine the Mongoose methods with the Express routes.

Also: 
- Customize the characteristics of the mongoose collection and separate the collection creating code into its own module.
- Using .env to hold critical environmental variables such as the MongoDB Atlas database's url and password


<br>
<br>
<br>

# 1- Create new node project:

I first used

    npm init

to create my new node project. It asks a series of questions to create a `package.json`.

I added a script in the script part of the brand new package.json file: "start": "node index.js"

    "scripts": {
      "start": "node index.js",
      "test": "echo \"Error: no test specified\" && exit 1"
    },

This line will initiate node index.js just writing "npm start" in the console.
The other line, "test", is added automatically when we create the node project. Is meant to run the tests that we write, but as we have no tests written yet it only displays an error message by now.

<br>

# 2- Installing Nodemon

Once that is done, I installed nodemon as dev dependency:

    npm install --save-dev nodemon

In the "scripts" part of the package.json file, I added  `"dev": "nodemon index.js"`

    "scripts": {
      "start": "node index.js",
      "test": "echo \"Error: no test specified\" && exit 1"
      "dev": "nodemon index.js",
    },

This line will allow me to run nodemon with the command line instruction: npm run test.
Instead of running the app with npm start, I have to use npm run test in order to run nodemon and have my backend changes updated at the moment.

<br>

# 3- Installing Express:

I instal express:

  npm install express

This creates a `node_modules` folder and a `package-lock.json` file.   
The "node_modules" folder contains Express's dependencies (and the dependencies of the dependencies of Express, and the dependencies of the dependencies of the dependencies of Express, and so on.)  
The package-lock.json file contains the name and version of each dependency included in node_modules. So, if someone installs our app with npm install, the right dependencies versions will be installed in the node_modules folder.

Simple express app:

    const express = require('express')
    const app = express()

    let notes = [
    'flower', 'path', 'unicorn'
    ]

    app.get('/', (request, response) => {
    response.send('<h1>Hello World!</h1>')
    })

    app.get('/api/notes', (request, response) => {
    response.json(notes)
    })

    const PORT = 3001
    app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`)
    })

1- Import express 
2- Creates an instance of the Express.js application using the express() function, which returns an Express application object. This object represents our web application and provides methods and properties for handling HTTP requests, defining routes, and configuring middleware.
3- Define two routes, one will answer to a HTTP GET to the root of our app (http://localhost:3001) and will respond sending `<h1>Hello World!</h1>`
  The other will answer to a HTTP GET request to '/api/notes', '/api/notes' (http://localhost:3001/api/notes), and will respond sending the list of notes we created. `['flower', 'path', 'unicorn']`
4- app.listen(PORT, () => { ... ) starts the server and makes it listen for incoming requests on the specified port. It takes two arguments: the port number (PORT) and a callback function that will execute once the server starts listening. In this case, it will print in console "Server running on port 3001".

<br>

# 4- Set up MongoDB Atlas

We will use a free Mongo database service called MongoDB Atlas https://www.mongodb.com/atlas/database  
We need to login (I logged in with google) and select the free option.  
Then it redirected me to the security quickstart tab, where I had to add a username and password to read and write data for the project.  
pauhiga was the `username`, 7APrQbs1fGGUVVDw was the autogenerated `password`. These will be the username and password I need to interact with my new database.  
Mongo says it automatically allowed my IP to work. If it doesn't work, I should put 0.0.0.0 as IP (in the Network Access tab in the left menu), so it will allow any IP.  
Now I click "Database" in the left menu and click in "Connect".  
A pop up window appears. I have to choose "Connect your application"  
Then Mongo gives some options, I leave Node as it is, and I copy the `connection string` provided:    
`mongodb+srv://pauhiga:<password>@cluster0.tz3jfik.mongodb.net/?retryWrites=true&w=majority`  
We will use this string later to connect our app to the database we just set up.  


# 5- Mongoose - Create a collection and save items in it

I first install mongoose:

  npm install mongoose

To use it, we need to:  
1- Import mongoose
2- Connect to the Mongo Atlas database
3- Create a schema, that defines the shape of the documents for the collection we're creating (basically the names of the fields and the data type of them, but we can also define other stuff like if a field is mandatory or not).
4- Turn the schema into a "Model", that is like a class we will use to create each entry of the database.
5- Use the Model "class" to create a new object to save in the database.
6- Save it and THEN close the connection.

Then I create a mongo.js file, and inside I throw this code:

    const mongoose = require('mongoose')
    const Schema = mongoose.Schema;

    if (process.argv.length<3) {
    console.log('Error! you need to give the password as argument in the command line')
    process.exit(1)
    }

    const password = process.argv[2]

    const url =
    `mongodb+srv://pauhiga:${password}@cluster0.tz3jfik.mongodb.net/?retryWrites=true&w=majority`

    mongoose.set('strictQuery',false)
    mongoose.connect(url)

    const productSchema = new mongoose.Schema({
      name: {
        type: String,
        required: true
      },
      featureImg: {
        type: String,
        required: true
      },
      galleryImg: {
        type: [String],
        required: false
      },
      description: {
        type: String,
        required: true
      },
      descriptionL: {
        type: String,
        required: false
      },
      price: {
        type: Number,
        required: true
      },
      stock: {
        type: Schema.Types.Mixed,
        required: true
      },
      category: {
        type: [String],
        required: true
      },
      discount: {
        type: Number,
        required: true,
        default: 0
      }
    })

    const Product = mongoose.model('Product', productSchema)

    const product = new Product({
      name: 'Floral woman dress',
      featureImg: 'img url',
      description: 'Summer woman dress',
      descriptionL: 'Beautiful Floral Summer woman dress in fresh colors',
      price: 35,
      stock: {'S': 10, 'M': 10, 'L': 10, 'XL':10},
      category: ['woman'],
      discount:10
    })

    product.save().then(result => {
    console.log('product saved!')
    mongoose.connection.close()
    })

<br>

In this part:

    const password = process.argv[2]

    const url =
    `mongodb+srv://pauhiga:${password}@cluster0.tz3jfik.mongodb.net/?retryWrites=true&w=majority`

The password is the password we created in step 4. We will put it into use as the second argument of the command line when we start the app with node + name of the file + password.
In our case: node mongo.js 7APrQbs1fGGUVVDw   
The const url is the connection string provided by mongo in step 4, only that instead of `<password>` we use `${password}` in order to place there the password provided by us as second argument in the command line.  

This code will create a database with the default name "test". To add the name we want, we need to add the name in the spot I marked as NAMEOFTHEDATABASE

    const url =
    `mongodb+srv://pauhiga:${password}@cluster0.tz3jfik.mongodb.net/NAMEOFTHEDATABASE?retryWrites=true&w=majority`

In our case:
    `mongodb+srv://pauhiga:${password}@cluster0.tz3jfik.mongodb.net/TheTroveStore?retryWrites=true&w=majority`

<br>
<br>


# 6- Mongoose - Fetch objects from the collection

To fetch the objects saved in the database, we use the same code as before but we replace the lines for creating a new note for this:

    Product.find({}).then(result => {
        result.forEach(item => {
        console.log(item)
        })
        mongoose.connection.close()
    })

Like in the former case, ALWAYS REMEMBER TO CLOSE THE CONNECTION INSIDE THE .THEN!!

If we want to fetch only the notes that fill a condition, we can write it in the parenthesis:

    Product.find({'discount': 10}).then(result => {
        // ...
    })


# 7- Connect the database and the backend

We need to copy the Mongoose definitions in our backend's index.js file.

We will copy, in order: the import mongoose part, the url to save in the constant url, the instructions to connect mongoose to that url and the creation of the schema + model.

NOTICE THAT THE PASSWORD IS HARDCODED IN THE CODE! We will handle that later.

    const mongoose = require('mongoose')
    const Schema = mongoose.Schema;

    const password = '7APrQbs1fGGUVVDw'

    const url =
    `mongodb+srv://pauhiga:${password}@cluster0.tz3jfik.mongodb.net/TheTroveStore?retryWrites=true&w=majority`

    mongoose.set('strictQuery',false)
    mongoose.connect(url)

    const productSchema = new mongoose.Schema({
      name: {
        type: String,
        required: true
      },
      featureImg: {
        type: String,
        required: true
      },
      galleryImg: {
        type: [String],
        required: false
      },
      description: {
        type: String,
        required: true
      },
      descriptionL: {
        type: String,
        required: false
      },
      price: {
        type: Number,
        required: true
      },
      stock: {
        type: Schema.Types.Mixed,
        required: true
      },
      category: {
        type: [String],
        required: true
      },
      discount: {
        type: Number,
        required: true,
        default: 0
      }
    })

    const Product = mongoose.model('Product', productSchema)

Then we combine the old instruction for fetching all:

OLD:

    app.get('/api/products', (request, response) => {
    response.send('<h1>Hello World!</h1>')
    })

With the code we saw in part 6 to fetch objects from the database:
NEW:

    app.get('/api/products', (request, response)=>{
        Product.find({}).then(item => {
            response.json(item)
        })
    })

Now we can run the app with `npm start` and we will see the elements of the collection in http://localhost:3001/api/products

<br>
<br>

# 8- Customize the mongoose schema

The HTTP GET request to http://localhost:3001/api/products produces this:

    [
        {
            "_id": "64864cc235f679018c0adb76",
            "name": "Floral woman dress",
            "featureImg": "img url",
            "galleryImg": [],
            "description": "Summer woman dress",
            "descriptionL": "Beautiful Floral Summer woman dress in fresh colors",
            "price": 35,
            "stock": {
                "S": 10,
                "M": 10,
                "L": 10,
                "XL": 10
            },
            "category": [
                "woman"
            ],
            "discount": 10,
            "__v": 0
        }
    ]

We will change two things: 
1- The "_id" property (that looks like a string, but refers to an object) will be changed into "id" and will be an actual string. 
2- We will remove the property "__v", that indicates the mongo versioning field. This number changes when the entry is updated. But we don't want that to be transmitted to the frontend, so we will remove it.

We will transform our productSchema using the .set() method. 

    productSchema.set('toJSON', {
        transform: (document, returnedObject) => {
            returnedObject.id = returnedObject._id.toString()
            delete returnedObject._id
            delete returnedObject.__v
        }
    })

Explanation: .set() accepts as arguments a "key" to modify and a "value" to set. in this case it sets the property 'toJSON' to have as value {transform: * function *}. This means that each time the toJSON method is called (for instance, each time the object is stringified), the function of transform will execute. The function as we see creates a new key "id" and sets to it the content of __id turned into a string, and then it deletes the keys __id and __v.


# 9- Separating the mongoose code in its own modules.

We will create a "models" folder. Inside it, we will save "products.js"

There we will move all the mongoose related code we passed to index.js: the mongoose import, the password/url part, the productSchema, the productSchema modification we made in part 8, and the creation of the mongoose model using the schema.

In the mongoose.conect(url) part, we can use .then() to display a message in the console when the connection is done, or catch an error displaying an error message in case the connection was not possible.

mongoose.connect(url).then(result => {
        console.log('connected to MongoDB')
    })
    .catch((error) => {
            console.log('error connecting to MongoDB:', error.message)
    })

In the final part, when we create the model based on the productSchema, we will change the line for the model to be ``exported``

OLD: 

    const Product = mongoose.model('Product', productSchema)

NEW:

    const Product = mongoose.model('Product', productSchema);
    module.exports = Product;

Or in short:

    module.exports = mongoose.model('Product', productSchema)


Now we import this in index.js with:

    const Product = require('./models/products')


and index.js works as if we didn't move the code at all. Magic.

<br>

# 10 - Finally hide the PASSWORD into an environmental variable

We will use "dotenv" to extract the password from a .env file at the root of our project.

    npm install dotenv

We create a .env file and we place inside the MONGODB_URI (that contains the password + url of the mongo database):

    MONGODB_URI=mongodb+srv://pauhiga:7APrQbs1fGGUVVDw@cluster0.tz3jfik.mongodb.net/TheTroveStore?retryWrites=true&w=majority

And we will also add the PORT we connect to.

    PORT=3001

NOTE 1: DO NOT ADD commas, or quotes, no nothing. I had a cryptic error "MongoWriteConcernError: No write concern mode named 'majority`' found in replica set configuration" for writing it like this:
MONGODB_URI = mongodb+srv://pauhiga:7APrQbs1fGGUVVDw@cluster0.tz3jfik.mongodb.net/TheTroveStore?retryWrites=true&w=majority`   
DON'T DO IT!

NOTE 2:   
NO NOT FORGET TO ADD THE .env FILE TO THE GITIGNORE!! Or we will be sharing the password with the world.

To call the data in the .env file in the products.js model, we use:

    require('dotenv').config()

    const url = process.env.MONGODB_URI

In the index.js file, we use it to obtain the port instead of hardcoding it:

    require('dotenv').config()

    const PORT = process.env.PORT   


Warning: Do not forget to call this AT THE TOP of the files (or at least, before the variables are needed in the code!)


We will return to this point when we need to set this environmental variables in the host service.


# 11- Route to create a new product

FIRST, we need to set up routes to access the data from http post requests.
The data sent in the request body is in JSON format. To access it, we have an express tool called json-parser. 

We need to add 

    app.use(express.json())

at the beginning of the file after we create the app constant.
IF WE DON'T DO THIS, ANY REQUEST.BODY WILL BE UNDEFINED!


Now, we can write our POST route:

  app.post('/api/products', (request, response) => {
    const body = request.body

    const product = new Product({
      name: body.name,
      featureImg: body.featureImg,
      galleryImg: body.galleryImg,
      description: body.description,
      descriptionL: body.descriptionL,
      price: body.price,
      stock: body.stock,
      category: body.category,
      discount:body.discount,
    })

    product.save().then(savedProduct => {
        response.json(savedProduct)
    })
  })